{% extends 'base/base.html' %}

{% block title %}数据包详情 - DPI防火墙系统{% endblock %}

{% block page_title %}数据包详情{% endblock %}

{% block page_actions %}
<a href="{% url 'packet_list' %}" class="btn btn-sm btn-outline-secondary">
    <i class="fas fa-arrow-left me-1"></i>返回列表
</a>
{% endblock %}

{% block content %}
<div class="row">
    <!-- 基本信息卡片 -->
    <div class="col-md-6">
        <div class="card mb-4">
            <div class="card-header">
                <i class="fas fa-info-circle me-2"></i>基本信息
            </div>
            <div class="card-body">
                <table class="table">
                    <tr>
                        <th style="width: 30%">捕获时间</th>
                        <td>{{ packet.timestamp|date:"Y-m-d H:i:s.u" }}</td>
                    </tr>
                    <tr>
                        <th>状态</th>
                        <td>
                            {% if packet.status == 'allowed' %}
                            <span class="badge bg-success">已允许</span>
                            {% elif packet.status == 'blocked' %}
                            <span class="badge bg-danger">已阻止</span>
                            {% else %}
                            <span class="badge bg-warning">可疑</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <th>方向</th>
                        <td>
                            {% if packet.direction == 'inbound' %}
                            <span class="badge bg-primary">入站</span>
                            {% else %}
                            <span class="badge bg-success">出站</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <th>数据包大小</th>
                        <td>{{ packet.packet_size }} 字节</td>
                    </tr>
                </table>
            </div>
        </div>

        <!-- 协议信息卡片 -->
        <div class="card mb-4">
            <div class="card-header">
                <i class="fas fa-network-wired me-2"></i>协议信息
            </div>
            <div class="card-body">
                <table class="table">
                    <tr>
                        <th style="width: 30%">协议</th>
                        <td>
                            {% if packet.protocol %}
                            <span class="badge bg-info">{{ packet.protocol.name }}</span>
                            {% else %}
                            <span class="badge bg-secondary">未知</span>
                            {% endif %}
                        </td>
                    </tr>
                    {% if packet.protocol and packet.protocol.description %}
                    <tr>
                        <th>协议描述</th>
                        <td>{{ packet.protocol.description }}</td>
                    </tr>
                    {% endif %}
                    {% if dpi_result %}
                    <tr>
                        <th>应用层协议</th>
                        <td>{{ dpi_result.application_protocol }}</td>
                    </tr>
                    {% if dpi_result.content_type %}
                    <tr>
                        <th>内容类型</th>
                        <td>{{ dpi_result.content_type }}</td>
                    </tr>
                    {% endif %}
                    {% endif %}
                </table>
            </div>
        </div>

        <!-- 规则匹配信息 -->
        {% if packet.matched_rule %}
        <div class="card mb-4">
            <div class="card-header">
                <i class="fas fa-shield-alt me-2"></i>匹配规则
            </div>
            <div class="card-body">
                <table class="table">
                    <tr>
                        <th style="width: 30%">规则名称</th>
                        <td>
                            <a href="{% url 'rule_detail' packet.matched_rule.id %}">
                                {{ packet.matched_rule.name }}
                            </a>
                        </td>
                    </tr>
                    <tr>
                        <th>规则动作</th>
                        <td>{{ packet.matched_rule.get_action_display }}</td>
                    </tr>
                    <tr>
                        <th>规则优先级</th>
                        <td>{{ packet.matched_rule.get_priority_display }}</td>
                    </tr>
                </table>
            </div>
        </div>
        {% endif %}
    </div>
    
    <!-- 连接信息卡片 -->
    <div class="col-md-6">
        <div class="card mb-4">
            <div class="card-header">
                <i class="fas fa-exchange-alt me-2"></i>连接信息
            </div>
            <div class="card-body">
                <table class="table">
                    <tr>
                        <th style="width: 30%">源IP地址</th>
                        <td>{{ packet.source_ip }}</td>
                    </tr>
                    <tr>
                        <th>源端口</th>
                        <td>{{ packet.source_port }}</td>
                    </tr>
                    <tr>
                        <th>目标IP地址</th>
                        <td>{{ packet.destination_ip }}</td>
                    </tr>
                    <tr>
                        <th>目标端口</th>
                        <td>{{ packet.destination_port }}</td>
                    </tr>
                </table>
                
                <div class="text-center my-4">
                    <div class="connection-diagram">
                        <div class="source p-2 border rounded">
                            <i class="fas fa-laptop me-2"></i>{{ packet.source_ip }}:{{ packet.source_port }}
                        </div>
                        <div class="arrow my-3">
                            {% if packet.direction == 'inbound' %}
                            <i class="fas fa-long-arrow-alt-down fa-2x text-primary"></i>
                            {% else %}
                            <i class="fas fa-long-arrow-alt-up fa-2x text-success"></i>
                            {% endif %}
                        </div>
                        <div class="destination p-2 border rounded">
                            <i class="fas fa-server me-2"></i>{{ packet.destination_ip }}:{{ packet.destination_port }}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- DPI分析结果卡片 -->
        {% if dpi_result %}
        <div class="card mb-4">
            <div class="card-header">
                <i class="fas fa-search-plus me-2"></i>深度检测结果
            </div>
            <div class="card-body">
                <table class="table">
                    <tr>
                        <th style="width: 30%">风险等级</th>
                        <td>
                            {% if dpi_result.risk_level == 'low' %}
                            <span class="badge bg-success">低风险</span>
                            {% elif dpi_result.risk_level == 'medium' %}
                            <span class="badge bg-warning">中风险</span>
                            {% else %}
                            <span class="badge bg-danger">高风险</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <th>是否恶意</th>
                        <td>
                            {% if dpi_result.is_malicious %}
                            <span class="text-danger"><i class="fas fa-exclamation-triangle me-1"></i>是</span>
                            {% else %}
                            <span class="text-success"><i class="fas fa-check me-1"></i>否</span>
                            {% endif %}
                        </td>
                    </tr>
                    {% if dpi_result.detected_patterns %}
                    <tr>
                        <th>检测到的模式</th>
                        <td>{{ dpi_result.detected_patterns }}</td>
                    </tr>
                    {% endif %}
                    
                    {% if dpi_result.decoded_content %}
                    <tr>
                        <th>解码内容</th>
                        <td>
                            <pre class="bg-light p-2 rounded" style="max-height: 200px; overflow-y: auto; font-size: 0.85rem; white-space: pre-wrap; word-break: break-word;">{{ dpi_result.decoded_content }}</pre>
                        </td>
                    </tr>
                    {% endif %}
                </table>
                
                {% if dpi_result.metadata %}
                <div class="mt-3">
                    <h6>元数据</h6>
                    <pre class="bg-light p-3 rounded"><code>{{ dpi_result.metadata|pprint }}</code></pre>
                </div>
                {% endif %}
            </div>
        </div>
        {% endif %}
    </div>
</div>

<!-- 数据包内容卡片 -->
<div class="card">
    <div class="card-header">
        <i class="fas fa-file-code me-2"></i>数据包内容
    </div>
    <div class="card-body">
        <div class="row mb-3">
            <div class="col-md-3 fw-bold">数据内容:</div>
            <div class="col-md-9">
                <div class="card">
                    <div class="card-header">
                        <ul class="nav nav-tabs card-header-tabs" id="packetDataTab" role="tablist">
                            <li class="nav-item">
                                <a class="nav-link active" id="info-tab" data-bs-toggle="tab" href="#info" role="tab">基本信息</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" id="raw-tab" data-bs-toggle="tab" href="#raw" role="tab">原始载荷</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" id="hex-tab" data-bs-toggle="tab" href="#hex" role="tab">十六进制</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" id="structure-tab" data-bs-toggle="tab" href="#structure" role="tab">数据包结构</a>
                            </li>
                        </ul>
                    </div>
                    <div class="card-body">
                        <div class="tab-content" id="packetDataTabContent">
                            <div class="tab-pane fade show active" id="info" role="tabpanel">
                                {% if packet_payload.info %}
                                    <pre class="rounded bg-light p-3" style="max-height: 300px; overflow-y: auto;">{{ packet_payload.info }}</pre>
                                {% else %}
                                    <div class="alert alert-info">没有基本信息数据</div>
                                {% endif %}
                            </div>
                            <div class="tab-pane fade" id="raw" role="tabpanel">
                                {% if packet_payload.raw %}
                                    <div class="mb-3 row">
                                        <div class="col-md-6">
                                            <select id="payload-decoder" class="form-select form-select-sm" onchange="decodePayload()">
                                                <option value="raw">原始数据</option>
                                                <option value="ascii">ASCII解码(显示十六进制)</option>
                                                <option value="hex">十六进制解码</option>
                                                <option value="base64">Base64尝试解码</option>
                                                <option value="utf8">UTF-8尝试解码</option>
                                                <option value="protocol">常见协议解析</option>
                                                <option value="binary">二进制解析</option>
                                                <option value="latin1">Latin-1解码</option>
                                                <option value="gb2312">GB2312/GBK解码</option>
                                                <option value="url">URL解码</option>
                                            </select>
                                        </div>
                                        <div class="col-md-6 text-end">
                                            <button id="binary-download" class="btn btn-sm btn-outline-secondary" onclick="downloadRawData()">
                                                <i class="fas fa-download me-1"></i>下载原始数据
                                            </button>
                                        </div>
                                    </div>
                                    <pre id="raw-payload-container" class="rounded bg-light p-3" style="max-height: 300px; overflow-y: auto;">{{ packet_payload.raw }}</pre>
                                    <div id="raw-original" style="display:none">{{ packet_payload.raw }}</div>
                                {% else %}
                                    <div class="alert alert-info">没有原始载荷数据</div>
                                {% endif %}
                            </div>
                            <div class="tab-pane fade" id="hex" role="tabpanel">
                                {% if packet_payload.hex %}
                                    <pre class="rounded bg-light p-3" style="max-height: 300px; overflow-y: auto; font-family: monospace;">{{ packet_payload.hex }}</pre>
                                {% else %}
                                    <div class="alert alert-info">没有十六进制数据</div>
                                {% endif %}
                            </div>
                            <div class="tab-pane fade" id="structure" role="tabpanel">
                                {% if packet_payload.structure %}
                                    <pre class="rounded bg-light p-3" style="max-height: 300px; overflow-y: auto;">{{ packet_payload.structure }}</pre>
                                {% else %}
                                    <div class="alert alert-info">没有数据包结构信息</div>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    .connection-diagram {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .source, .destination {
        width: 100%;
        background-color: #f8f9fa;
    }
    pre {
        margin-bottom: 0;
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
    // 解码选项切换逻辑
    function decodePayload() {
        const decoder = document.getElementById('payload-decoder').value;
        const originalData = document.getElementById('raw-original').textContent;
        const container = document.getElementById('raw-payload-container');
        
        try {
            let decoded = '';
            
            switch(decoder) {
                case 'raw':
                    decoded = originalData;
                    break;
                
                case 'hex':
                    // 将数据转换为连续的十六进制表示
                    decoded = '十六进制解码:\n';
                    const cleanData = originalData.replace(/[\r\n=== RAW PAYLOAD ===]/g, '').trim();
                    const bytes = [];
                    
                    for (let i = 0; i < cleanData.length; i++) {
                        const code = cleanData.charCodeAt(i);
                        bytes.push(code.toString(16).padStart(2, '0'));
                    }
                    
                    // 格式化为每行16字节
                    for (let i = 0; i < bytes.length; i += 16) {
                        const offset = i.toString(16).padStart(8, '0');
                        const line = bytes.slice(i, i + 16);
                        const hexPart = line.join(' ').padEnd(48, ' ');
                        
                        // 生成ASCII部分
                        const asciiPart = line.map(hex => {
                            const code = parseInt(hex, 16);
                            return (code >= 32 && code < 127) ? String.fromCharCode(code) : '.';
                        }).join('');
                        
                        decoded += `${offset}: ${hexPart} | ${asciiPart}\n`;
                    }
                    break;
                
                case 'ascii':
                    // 将不可打印字符转换为十六进制表示
                    decoded = Array.from(originalData)
                        .map(char => {
                            const code = char.charCodeAt(0);
                            if (code >= 32 && code < 127) {
                                return char;
                            } else {
                                return `\\x${code.toString(16).padStart(2, '0')}`;
                            }
                        })
                        .join('');
                    break;
                
                case 'base64':
                    // 尝试将数据作为base64解码
                    try {
                        // 清理数据，提取可能的base64编码部分
                        let cleanData = originalData.replace(/[\r\n=== RAW PAYLOAD ===]/g, '').trim();
                        // 查找符合base64编码特征的部分
                        const base64Regex = /[A-Za-z0-9+/=]{8,}/g;
                        const matches = cleanData.match(base64Regex);
                        
                        if (matches && matches.length > 0) {
                            decoded = "尝试解码找到的Base64数据:\n\n";
                            
                            for (const match of matches) {
                                if (match.length >= 8) { // 避免太短的匹配
                                    decoded += `原始Base64: ${match.substring(0, 50)}${match.length > 50 ? '...' : ''}\n`;
                                    try {
                                        const decodedText = atob(match);
                                        // 检查解码结果是否有意义
                                        const readableChars = Array.from(decodedText).filter(c => {
                                            const code = c.charCodeAt(0);
                                            return code >= 32 && code < 127;
                                        }).length;
                                        
                                        // 如果至少60%是可打印字符，显示解码结果
                                        if (readableChars / decodedText.length >= 0.6) {
                                            decoded += `解码结果: ${decodedText.substring(0, 100)}${decodedText.length > 100 ? '...' : ''}\n\n`;
                                        } else {
                                            // 否则显示十六进制
                                            const hexResult = Array.from(decodedText)
                                                .map(c => c.charCodeAt(0).toString(16).padStart(2, '0'))
                                                .join(' ');
                                            decoded += `解码结果(十六进制): ${hexResult.substring(0, 100)}${hexResult.length > 100 ? '...' : ''}\n\n`;
                                        }
                                    } catch (e) {
                                        decoded += `解码失败: ${e.message}\n\n`;
                                    }
                                }
                            }
                        } else {
                            decoded = "未找到符合Base64特征的数据。";
                        }
                    } catch (e) {
                        decoded = '无法进行Base64解码: ' + e.message;
                    }
                    break;
                
                case 'utf8':
                    // 尝试将二进制数据解析为UTF-8编码字符串
                    try {
                        // 提取二进制数据
                        const dataChunks = originalData.split('\n');
                        let byteString = '';
                        
                        // 查找并解码十六进制转储部分
                        let hexDumpFound = false;
                        for (let i = 0; i < dataChunks.length; i++) {
                            if (dataChunks[i].trim() === '=== HEXDUMP ===') {
                                hexDumpFound = true;
                                // 从下一行开始读取十六进制数据
                                for (let j = i + 1; j < dataChunks.length; j++) {
                                    if (dataChunks[j].trim() === '=== PACKET STRUCTURE ===' || dataChunks[j].trim() === '') {
                                        break;
                                    }
                                    const hexLine = dataChunks[j].trim();
                                    if (hexLine) {
                                        // 移除所有空格，只保留十六进制字符
                                        byteString += hexLine.replace(/\s+/g, '');
                                    }
                                }
                                break;
                            }
                        }
                        
                        if (hexDumpFound && byteString) {
                            // 将十六进制字符串转换为二进制数据
                            const bytes = new Uint8Array(byteString.length / 2);
                            for (let i = 0; i < byteString.length; i += 2) {
                                bytes[i / 2] = parseInt(byteString.substr(i, 2), 16);
                            }
                            
                            // 尝试UTF-8解码
                            decoded = new TextDecoder('utf-8').decode(bytes);
                            
                            // 如果结果大部分是不可打印字符，改用十六进制展示
                            const readableChars = Array.from(decoded).filter(c => {
                                const code = c.charCodeAt(0);
                                return code >= 32 && code < 127;
                            }).length;
                            
                            if (readableChars / decoded.length < 0.6) {
                                decoded = 'UTF-8解码结果包含大量不可打印字符，以下是可读字符提取:\n\n';
                                decoded += Array.from(new TextDecoder('utf-8').decode(bytes))
                                    .map(c => {
                                        const code = c.charCodeAt(0);
                                        return (code >= 32 && code < 127) ? c : '.';
                                    })
                                    .join('');
                            }
                        } else {
                            // 直接尝试UTF-8解码原始内容
                            decoded = "UTF-8直接解码尝试:\n" + originalData;
                        }
                    } catch (e) {
                        decoded = '无法解析为UTF-8: ' + e.message;
                    }
                    break;
                
                case 'protocol':
                    // 尝试识别和解析常见协议
                    decoded = "协议分析结果:\n\n";
                    
                    // 检查常见协议特征
                    if (originalData.includes('HTTP/1.') || originalData.includes('GET ') || 
                        originalData.includes('POST ') || originalData.includes('Host:')) {
                        decoded += "检测到HTTP协议数据\n";
                        // 提取HTTP头
                        const httpMatch = originalData.match(/(GET|POST|PUT|HEAD|DELETE) .+HTTP\/\d\.\d.+?\r?\n\r?\n/s);
                        if (httpMatch) {
                            decoded += "HTTP头:\n" + httpMatch[0] + "\n";
                        }
                    } else if (originalData.includes('SSH-')) {
                        decoded += "检测到SSH协议数据\n";
                        const sshMatch = originalData.match(/SSH-.+?\r?\n/);
                        if (sshMatch) {
                            decoded += "SSH版本: " + sshMatch[0] + "\n";
                        }
                    } else if (originalData.includes('SMTP') || originalData.includes('220 ')) {
                        decoded += "检测到SMTP协议数据\n";
                    } else if (originalData.includes('IMAP')) {
                        decoded += "检测到IMAP协议数据\n";
                    } else if (originalData.includes('POP3')) {
                        decoded += "检测到POP3协议数据\n";
                    } else if (originalData.includes('FTP')) {
                        decoded += "检测到FTP协议数据\n";
                    } else if (originalData.includes('DNS')) {
                        decoded += "检测到DNS协议数据\n";
                    } else {
                        // 检查是否包含常见的文件头部
                        if (originalData.startsWith('PK')) {
                            decoded += "检测到ZIP文件或Office文档 (PK头部)\n";
                        } else if (originalData.includes('JFIF') || originalData.includes('JPEG')) {
                            decoded += "检测到JPEG图像文件\n";
                        } else if (originalData.includes('PNG')) {
                            decoded += "检测到PNG图像文件\n";
                        } else if (originalData.includes('GIF')) {
                            decoded += "检测到GIF图像文件\n";
                        } else if (originalData.includes('PDF')) {
                            decoded += "检测到PDF文档\n";
                        } else {
                            decoded += "无法识别特定协议特征\n";
                        }
                    }
                    
                    // 检查是否包含常见文件类型内容
                    if (originalData.includes('<!DOCTYPE html>') || originalData.includes('<html>')) {
                        decoded += "包含HTML内容\n";
                    } else if (originalData.includes('<?xml')) {
                        decoded += "包含XML内容\n";
                    } else if (originalData.match(/\{\s*"[^"]+"\s*:/)) {
                        decoded += "包含JSON内容\n";
                        try {
                            // 尝试找到JSON部分
                            const jsonMatch = originalData.match(/\{[^}]*\}/);
                            if (jsonMatch) {
                                const jsonData = JSON.parse(jsonMatch[0]);
                                decoded += "JSON内容摘要:\n" + JSON.stringify(jsonData, null, 2).substring(0, 500) + "\n";
                            }
                        } catch (e) {
                            // 不是有效JSON
                        }
                    }
                    
                    decoded += "\n原始数据:\n" + originalData;
                    break;
                
                case 'binary':
                    // 二进制数据分析
                    decoded = "二进制数据分析:\n\n";
                    
                    try {
                        // 尝试从原始数据中提取二进制特征
                        const dataBytes = Array.from(originalData).map(c => c.charCodeAt(0));
                        
                        // 检查数据特征
                        const totalBytes = dataBytes.length;
                        const nullBytes = dataBytes.filter(b => b === 0).length;
                        const printableChars = dataBytes.filter(b => b >= 32 && b < 127).length;
                        const controlChars = dataBytes.filter(b => b < 32 || b === 127).length;
                        const highBitChars = dataBytes.filter(b => b >= 128).length;
                        
                        decoded += `总字节数: ${totalBytes}\n`;
                        decoded += `可打印ASCII字符: ${printableChars} (${(printableChars/totalBytes*100).toFixed(2)}%)\n`;
                        decoded += `控制字符: ${controlChars} (${(controlChars/totalBytes*100).toFixed(2)}%)\n`;
                        decoded += `高位字节(>=128): ${highBitChars} (${(highBitChars/totalBytes*100).toFixed(2)}%)\n`;
                        decoded += `空字节(0x00): ${nullBytes} (${(nullBytes/totalBytes*100).toFixed(2)}%)\n\n`;
                        
                        // 字节分布统计
                        const distribution = {};
                        for (const byte of dataBytes) {
                            distribution[byte] = (distribution[byte] || 0) + 1;
                        }
                        
                        // 找出最常见的几个字节
                        const topBytes = Object.entries(distribution)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 10);
                            
                        decoded += "最常见的字节:\n";
                        for (const [byte, count] of topBytes) {
                            const hexByte = parseInt(byte).toString(16).padStart(2, '0');
                            const charRepresentation = byte >= 32 && byte < 127 ? String.fromCharCode(byte) : '.';
                            decoded += `0x${hexByte} (${charRepresentation}): ${count} 次 (${(count/totalBytes*100).toFixed(2)}%)\n`;
                        }
                        
                        // 数据类型推测
                        decoded += "\n数据类型推测:\n";
                        
                        if (printableChars / totalBytes > 0.8) {
                            decoded += "可能是文本数据 (ASCII/UTF-8)\n";
                        } else if (nullBytes / totalBytes > 0.3) {
                            decoded += "可能是包含Unicode字符串的数据 (UTF-16/UTF-32)\n";
                        } else if (highBitChars / totalBytes > 0.5) {
                            decoded += "可能是二进制可执行文件或压缩数据\n";
                        }
                        
                        // 提取连续的可打印字符字符串
                        decoded += "\n可提取的字符串:\n";
                        let currentString = "";
                        for (let i = 0; i < dataBytes.length; i++) {
                            const byte = dataBytes[i];
                            if (byte >= 32 && byte < 127) {
                                currentString += String.fromCharCode(byte);
                            } else if (currentString.length >= 4) { // 只显示至少4个字符的字符串
                                decoded += currentString + "\n";
                                currentString = "";
                            } else {
                                currentString = "";
                            }
                        }
                        if (currentString.length >= 4) {
                            decoded += currentString + "\n";
                        }
                        
                    } catch (e) {
                        decoded += '分析过程中出错: ' + e.message;
                    }
                    break;
                
                case 'latin1':
                    // Latin-1解码
                    try {
                        // 将数据视为Latin-1编码字符
                        decoded = Array.from(originalData)
                            .map(char => {
                                const code = char.charCodeAt(0);
                                if (code >= 32 && code < 127 || (code >= 160 && code <= 255)) {
                                    return char;
                                } else {
                                    return `.`;
                                }
                            })
                            .join('');
                        decoded = "Latin-1解码尝试:\n" + decoded;
                    } catch (e) {
                        decoded = '无法解析为Latin-1: ' + e.message;
                    }
                    break;
                    
                case 'gb2312':
                    // 尝试GB2312/GBK解码
                    try {
                        decoded = "GB2312/GBK解码尝试:\n";
                        decoded += "注意: 浏览器端无法直接解码GB2312，这只是字节模式展示\n\n";
                        
                        // 提取十六进制转储
                        const dataChunks = originalData.split('\n');
                        let byteString = '';
                        
                        // 查找并解码十六进制转储部分
                        let hexDumpFound = false;
                        for (let i = 0; i < dataChunks.length; i++) {
                            if (dataChunks[i].trim() === '=== HEXDUMP ===') {
                                hexDumpFound = true;
                                // 从下一行开始读取十六进制数据
                                for (let j = i + 1; j < dataChunks.length; j++) {
                                    if (dataChunks[j].trim() === '=== PACKET STRUCTURE ===' || dataChunks[j].trim() === '') {
                                        break;
                                    }
                                    const hexLine = dataChunks[j].trim();
                                    if (hexLine) {
                                        // 移除所有空格，只保留十六进制字符
                                        byteString += hexLine.replace(/\s+/g, '');
                                    }
                                }
                                break;
                            }
                        }
                        
                        if (hexDumpFound && byteString) {
                            // 将十六进制字符串转换为字节数组
                            const bytes = [];
                            for (let i = 0; i < byteString.length; i += 2) {
                                bytes.push(parseInt(byteString.substr(i, 2), 16));
                            }
                            
                            // 基于常见中文字符范围进行分析
                            let possibleChineseText = '';
                            for (let i = 0; i < bytes.length; i++) {
                                // 检查是否可能是GB2312/GBK双字节
                                if (i + 1 < bytes.length && bytes[i] >= 0x81 && bytes[i] <= 0xFE) {
                                    possibleChineseText += `[可能的中文字符:${bytes[i].toString(16)}-${bytes[i+1].toString(16)}] `;
                                    i++; // 跳过下一个字节
                                } else if (bytes[i] >= 32 && bytes[i] < 127) {
                                    // ASCII可打印字符
                                    possibleChineseText += String.fromCharCode(bytes[i]);
                                } else {
                                    // 其他字节
                                    possibleChineseText += `.`;
                                }
                            }
                            
                            decoded += possibleChineseText;
                        } else {
                            decoded += "未找到十六进制转储数据，无法进行GB2312/GBK解码尝试。";
                        }
                    } catch (e) {
                        decoded = '尝试GB2312/GBK解析时出错: ' + e.message;
                    }
                    break;
                
                case 'url':
                    // URL解码
                    try {
                        // 尝试URL解码
                        decoded = "URL解码尝试:\n";
                        
                        // 查找类似URL编码的部分
                        const urlRegex = /%[0-9A-Fa-f]{2}/g;
                        const matches = originalData.match(urlRegex);
                        
                        if (matches && matches.length > 0) {
                            decoded += `找到 ${matches.length} 个URL编码序列 (%xx)。\n\n`;
                            try {
                                // 尝试解码整个内容
                                const decodedUrl = decodeURIComponent(originalData.replace(/\n/g, ' '));
                                decoded += `完整解码结果:\n${decodedUrl}\n\n`;
                                
                                // 提取可能的参数
                                const paramRegex = /[?&]([^=&]+)=([^&]*)/g;
                                const params = [];
                                let paramMatch;
                                
                                while ((paramMatch = paramRegex.exec(decodedUrl)) !== null) {
                                    params.push({name: paramMatch[1], value: paramMatch[2]});
                                }
                                
                                if (params.length > 0) {
                                    decoded += "URL参数:\n";
                                    for (const param of params) {
                                        decoded += `${param.name} = ${param.value}\n`;
                                    }
                                }
                            } catch (e) {
                                decoded += `完整解码失败: ${e.message}\n`;
                                
                                // 尝试解码单个%xx序列
                                decoded += "单个编码序列解码:\n";
                                const uniqueEncodings = [...new Set(matches)];
                                for (const encoded of uniqueEncodings) {
                                    try {
                                        const decoded = decodeURIComponent(encoded);
                                        decoded += `${encoded} → ${decoded}\n`;
                                    } catch (e) {
                                        decoded += `${encoded} → 解码失败\n`;
                                    }
                                }
                            }
                        } else {
                            decoded += "未找到URL编码序列。";
                        }
                    } catch (e) {
                        decoded = '解析URL编码时出错: ' + e.message;
                    }
                    break;
                    
                default:
                    decoded = originalData;
            }
            
            container.textContent = decoded;
            
        } catch (e) {
            container.textContent = '解码时出错: ' + e.message;
        }
    }
    
    // 下载原始数据
    function downloadRawData() {
        try {
            const originalData = document.getElementById('raw-original').textContent;
            
            // 提取仅包含Raw Payload部分
            let rawData = originalData;
            const startMarker = '=== RAW PAYLOAD ===';
            const endMarker = '=== HEXDUMP ===';
            
            const startIndex = originalData.indexOf(startMarker);
            const endIndex = originalData.indexOf(endMarker);
            
            if (startIndex !== -1 && endIndex !== -1) {
                rawData = originalData.substring(startIndex + startMarker.length, endIndex).trim();
            }
            
            // 创建Blob
            const blob = new Blob([rawData], {type: 'application/octet-stream'});
            const url = URL.createObjectURL(blob);
            
            // 创建下载链接
            const a = document.createElement('a');
            a.href = url;
            a.download = 'packet_payload_{{ packet.id }}.bin';
            document.body.appendChild(a);
            a.click();
            
            // 清理
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        } catch (e) {
            alert('下载数据失败: ' + e.message);
        }
    }
</script>
{% endblock %}